<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/veneer-terminal.js - veneer-terminal</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://media.usabilitydynamics.com/logo.png" title="veneer-terminal"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Terminal.html">Terminal</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/veneer-terminal.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Veneer Terminal
 *
 * @version 1.0.2
 *
 * @class Terminal
 * @author potanin@UD
 * @repository http://github.com/UsabilityDynamics/node-veneer-terminal
 *
 * @constructor
 * @params callback
 */
function Terminal( handler ) {

  // Inherit Terminal prototype into handler.
  this.utility.inherits( handler, Terminal );

  // Extend Child Instance with Event Emitter and Settings
  require( &#x27;object-emitter&#x27; ).mixin( handler.prototype );
  require( &#x27;object-settings&#x27; ).mixin( handler.prototype );

  // Find Best Package for Terminal settings.
  handler.prototype.set( require( this.utility.findup( &#x27;package.json&#x27;, { cwd: require( &#x27;path&#x27; ).dirname( process.mainModule.filename ) } ) ) );

  // Configure commander.
  handler.prototype.commander._name = handler.prototype.get( &#x27;name&#x27; );
  handler.prototype.commander.version( handler.prototype.get( &#x27;version&#x27; ) );
  handler.prototype.commander.usage( handler.prototype.get( &#x27;usage&#x27;, &#x27;[command] [options]&#x27; ) );

  // Extend own context.
  handler.prototype = new handler( null, handler.prototype );

  if( process.argv.length === 2 ) {
    handler.prototype.commander.outputHelp();
  } else {
    handler.prototype.commander.parse( process.argv );
  }

  return handler.prototype;

}

/**
 * Terminal Instance Properties
 *
 */
Object.defineProperties( Terminal.prototype, {
  log: {
    /**
     * Commander Instance
     * @for Terminal
     */
    value: function() {

      // Prefix with name of terminal
      arguments[0] = [ this.get( &#x27;name&#x27; ), arguments[0] ].join( &#x27;: &#x27; );

      // Output to console.
      console.log.apply( console, arguments );

      // @chainable.
      return this;

    },
    enumerable: false,
    configurable: true
  },
  write: {
    /**
     * Console Output
     *
     * @for Terminal
     */
    value: function write( string ) {

      console.log( string.blue );

      // @chainable.
      return this;

    },
    enumerable: false,
    configurable: true
  },
  commander: {
    /**
     * Commander Instance
     * @for Terminal
     */
    value: require( &#x27;commander&#x27; ),
    enumerable: false,
    configurable: true
  },
  option: {
    /**
     * Terminal Command
     */
    value: function option( flags, description, fn, defaultValue ) {
      return this.commander.option( flags, description, fn, defaultValue )
    },
    enumerable: true,
    configurable: true
  },
  command: {
    /**
     * Terminal Command
     */
    value: function command( name, desc ) {
      return this.commander.command( name ).description( desc )
    },
    enumerable: true,
    configurable: true
  },
  debug: {
    /**
     * Terminal Debugger
     *
     * @for Terminal
     * @method debug
     *
     * @param callback
     * @returns {Terminal}
     */
    value: require( &#x27;debug&#x27; )( &#x27;veneer:terminal&#x27; ),
    enumerable: true,
    configurable: true,
    writable: true
  },
  app_path: {
    /**
     * Get Path to Application
     *
     * @todo Fix.
     *
     * @param _package
     * @param targetName
     * @returns {string}
     */
    value: function app_path ( _package, targetName ) {
      return &quot;/home/&quot; + this._module.package.targets[targetName].ssh.user + &quot;/&quot; + targetName + &quot;/&quot; + _package.name;
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  inline_env: {
    value: function inline_env ( it ) {

      function qescape ( it ) {
        return it.replace( /\\/g, &quot;\\\\&quot; ).replace( /\&#x27;/g, &quot;\\&#x27;&quot; ).replace( /\&#x60;/g, &quot;\\&#x60;&quot; );
      }

      function qqescape ( it ) {
        return it.replace( /\\/g, &quot;\\\\&quot; ).replace( /\&quot;/g, &#x27;\\&quot;&#x27; );
      }

      var k, v, items = [];
      for( k in it ) {
        v = it[k] === null ? &quot;&quot; : it[k].toString();
        items.push( k + &quot;=\&quot;&quot; + qqescape( v ) + &quot;\&quot;&quot; );
      }
      return items.join( &quot; &quot; );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  sshs: {
    value: function sshs ( conf, cmds ) {
      Terminal.debug( &#x27;Executing SSH command(s).&#x27; );
      var exec = require( &#x27;child_process&#x27; ).exec;

      function qescape ( it ) {
        return it.replace( /\\/g, &quot;\\\\&quot; ).replace( /\&#x27;/g, &quot;\\&#x27;&quot; ).replace( /\&#x60;/g, &quot;\\&#x60;&quot; );
      }

      function qqescape ( it ) {
        return it.replace( /\\/g, &quot;\\\\&quot; ).replace( /\&quot;/g, &#x27;\\&quot;&#x27; );
      }

      function ssh ( conf, cmd ) {
        conf.hosts.forEach( function( host ) {
          var args = [
            &quot;-o&quot;, &quot;ForwardAgent=yes&quot;, &quot;-o&quot;, &quot;StrictHostKeyChecking=no&quot;, &quot;-p&quot;, conf.port, conf.user + &quot;@&quot; + host, &quot;bash -c &#x27;&quot; + qescape( cmd ) + &quot;&#x27;&quot;
          ];
          console.log( &quot;ssh&quot;, args );
          exec( &quot;ssh&quot;, args );
        } );
      }

      ssh( conf, cmds.join( &quot; &amp;&amp; &quot; ) );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  init: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function init ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( &quot;Invalid target:&quot;, targetName );
        process.exit( 1 );
      }
      var destAppPath = this.app_path( _package, targetName );
      var repoUrl = _package.repository.url;
      if( !repoUrl || _package.repository.type !== &#x27;git&#x27; ) {
        console.error( &quot;package.json must have repository of type &#x27;git&#x27;&quot; );
        process.exit( 1 );
      }
      sshs( targetConf.ssh, [
        &quot;mkdir -p &quot; + destAppPath, &quot;git clone &quot; + repoUrl + &quot; &quot; + destAppPath, &quot;cd &quot; + destAppPath, &quot;npm install&quot;
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  start: {
    /**
     * Start Module
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function start ( module, callback ) {
      Terminal.debug( &#x27;Start Module.&#x27; );

      // Veneer Cluster and Service handlers.
      var Cluster = require( &#x27;veneer-cluster&#x27; );
      var Service = require( &#x27;veneer-service&#x27; );

      // Start Service
      if( this._package.type === &#x27;service&#x27; ) {
        this._instance = Service.start( this._module, this._callback );
      }

      // Start Module
      if( this._package.type === &#x27;cluster&#x27; ) {
        this._instance = Cluster.start( this._module, this._callback );
      }

      console.log( require( &#x27;util&#x27; ).inspect( this._instance, { showHidden: false, colors: true, depth: 2 } ) )

    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  stop: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function stop ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( &quot;Invalid target:&quot;, targetName );
        process.exit( 1 );
      }
      sshs( targetConf.ssh, [
        &quot;cd &quot; + app_path( _package, targetName ), &quot;npm stop&quot;
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  list: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function list ( optParser, _package ) {
      Terminal.debug( &#x27;Listing options.&#x27; );

      var name, target;
      for( name in _package.config.targets ) {
        target = _package.config.targets[name];
        console.log( name )
        target.ssh.hosts.forEach( printHost );
      }
      function printHost ( host ) {
        console.log( &quot;  &quot; + host );
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  deploy: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function deploy ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).default( &#x27;branch&#x27;, null ).default( &#x27;npmforce&#x27;, null ).argv;

      if( !this._module.package.targets ) {
        console.error( &quot;package.json missing &#x27;config.targets&#x27; config&quot; );
        process.exit( 1 );
      }

      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      var forceCommand = &quot;&quot;;

      if( argv.npmforce ) {
        forceCommand = &quot; --force&quot;
      }

      if( !targetConf ) {
        console.error( &quot;Invalid target:&quot;, targetName );
        process.exit( 1 );
      }
      var env = this.inline_env( targetConf.env );
      if( argv.branch ) {
        proceed( null, argv.branch );
      } else {
        this.default_branch( proceed );
      }

      function proceed ( err, branch ) {
        if( err ) {
          console.error( &quot;Unable to get current branch:&quot;, err.stack );
          return;
        }

        sshs( targetConf.ssh, [
          &quot;cd &quot; + app_path( _package, targetName ), &quot;git fetch&quot;, &quot;git checkout origin/&quot; + branch, &quot;git submodule update&quot;, &quot;npm prune&quot;, &quot;npm install&quot; + forceCommand, env + &quot; npm run deploy&quot; ] );
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  abort: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function abort ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( &quot;Invalid target:&quot;, targetName );
        process.exit( 1 );
      }
      sshs( targetConf.ssh, [
        &quot;cd &quot; + app_path( _package, targetName ), &quot;npm run deploy-abort&quot;
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  monitor: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function monitor ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( &quot;Invalid target:&quot;, targetName );
        process.exit( 1 );
      }
      _package.config.commands = _package.config.commands || {};
      var tailCmd = _package.config.commands.monitor || &quot;tail -f *.log&quot;;
      sshs( targetConf.ssh, [
        &quot;cd &quot; + app_path( _package, targetName ), tailCmd
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  diff: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function diff ( optParser, _package ) {

      // Private Modules
      var Batch = require( &#x27;batch&#x27; );
      var argv = this._optParser.demand( 1 ).default( &#x27;branch&#x27;, null ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]

      if( !targetConf ) {
        console.error( &quot;Invalid target:&quot;, targetName );
        process.exit( 1 );
      }
      if( argv.branch ) {
        proceed( null, argv.branch );
      } else {
        this.default_branch( proceed );
      }
      function proceed ( err, branch ) {
        if( err ) {
          console.error( &quot;unable to get current branch:&quot;, err.stack );
          return;
        }
        this.deploy_diff( _package, targetName, branch, &quot;%C(yellow)%h%Creset %Cgreen%cd%Creset %Cred%an%Creset %s&quot;, function( err, gitLog ) {
          if( err ) {
            console.error( &quot;Unable to get diff:&quot;, err.stack );
          } else {
            if( !gitLog.trim() ) {
              console.log( &quot;No new code to deploy.&quot; );
            } else {
              console.log( gitLog );
            }
          }
        } );
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  get_usage: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function get_usage () {
      var usage = &quot;Usage: $0 [command]\n\nAvailable commands:\n&quot;;
      var task;

      for( var taskName in Terminal.tasks ) {
        task = Terminal.tasks[taskName];
        usage += &quot;\n    &quot; + taskName + &quot;\t&quot; + task.info;
      }

      return usage;

    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  exec: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function exec ( cmd, args, opts, cb ) {
      args = args || [];
      opts = opts || {};
      cb = cb || function() {
      };
      opts = this.utility.extend( {
        stdio: [process.stdin, process.stdout, process.stderr]
      }, opts );
      var bin = spawn( cmd, args, opts );
      bin.on( &#x27;exit&#x27;, cb );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  deploy_diff: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function deploy_diff ( _package, targetName, branch, format, cb ) {
      var exec = require( &#x27;child_process&#x27; ).exec;
      var batch = new Batch();
      batch.push( function( cb ) {
        var sshConf = _package.config.targets[targetName].ssh;
        var firstHost = sshConf.hosts[0];
        var destAppPath = app_path( _package, targetName );
        var cmd = &quot;ssh &quot; + &quot;-o ForwardAgent=yes &quot; + &quot;-p &quot; + sshConf.port + &quot; &quot; + sshConf.user + &quot;@&quot; + firstHost + &quot; &quot; + &quot;&#x27;cd &quot; + destAppPath + &quot; &amp;&amp; git rev-parse HEAD&#x27;&quot;;
        exec( cmd, function( err, stdout, stderr ) {
          if( err ) {
            err.stderr = stderr;
            err.stdout = stdout;
            err.cmd = cmd;
            cb( err );
          } else {
            cb( null, stdout.trim() );
          }
        } );
      } );
      batch.push( function( cb ) {
        var cmd = &quot;git fetch origin&quot;;
        exec( cmd, function( err, stdout, stderr ) {
          if( err ) {
            err.stderr = stderr;
            err.stdout = stdout;
            err.cmd = cmd;
            cb( err );
          } else {
            cb();
          }
        } );
      } );
      batch.end( function( err, results ) {
        if( err ) {
          return cb( err );
        }
        var rev = results[0];
        var cmd = &quot;git log --pretty=format:\&quot;&quot; + format + &quot;\&quot; &quot; + rev + &quot;..origin/&quot; + branch;
        exec( cmd, function( err, stdout, stderr ) {
          if( err ) {
            err.stderr = stderr;
            err.stdout = stdout;
            err.cmd = cmd;
            cb( err );
          } else {
            cb( null, stdout.trim() );
          }
        } );
      } );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  default_branch: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function default_branch ( cb ) {
      var exec = require( &#x27;child_process&#x27; ).exec;
      var cmd = &quot;git rev-parse --abbrev-ref HEAD&quot;;
      exec( cmd, function( err, stdout, stderr ) {
        if( err ) {
          err.stderr = stderr;
          err.stdout = stdout;
          err.cmd = cmd;
          cb( err );
        } else {
          cb( null, stdout.trim() );
        }
      } );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  run_env: {
    /**
     * Start Terminal
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function run_env ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1];
      var target = _package.config.targets[targetName];
      if( !target ) {
        console.error( &quot;Invalid target:&quot;, targetName );
        process.exit( 1 );
      }
      var args = argv._.slice( 2 )
      var env = this.utility.extend( this.utility.extend( {}, target.env ), process.env )
      var child = spawn( &#x27;bash&#x27;, [&#x27;-c&#x27;, args.join( &quot; &quot; )], {
        stdio: &#x27;inherit&#x27;,
        env: env,
      } )
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  utility: {
    /**
     * Terminal Utilities
     *
     * @for Terminal
     */
    value: require( &#x27;./common/utility&#x27; ),
    enumerable: true,
    configurable: true,
    writable: true
  }
});

/**
 * Export Terminal Class
 *
 */
Object.defineProperties( module.exports = Terminal, {
  create: {
    /**
     * Create Terminal Instance
     *
     * @param callback
     * @returns {Terminal}
     */
    value: function create ( handler ) {
      return new Terminal( handler );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  tasks: {
    value: {
      list: {
        fn: Terminal.prototype.list,
        info: &quot;list available deploy targets&quot;
      },
      init: {
        fn: Terminal.prototype.init,
        info: &quot;&lt;target&gt; - prepares target to accept deployments&quot;
      },
      start: {
        fn: Terminal.prototype.start,
        info: &quot;&lt;target&gt; - starts the remote server&quot;
      },
      stop: {
        fn: Terminal.prototype.stop,
        info: &quot;&lt;target&gt; - stops the remote server&quot;
      },
      deploy: {
        fn: Terminal.prototype.deploy,
        info: &quot;&lt;target&gt; [--branch branch] [--npmforce] - deploy code&quot;
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  }
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
