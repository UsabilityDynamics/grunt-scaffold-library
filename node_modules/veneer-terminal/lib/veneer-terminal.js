/**
 * Veneer veneerTerminal
 *
 * @version 1.0.3
 *
 * @class veneerTerminal
 * @author potanin@UD
 * @repository http://github.com/UsabilityDynamics/node-veneer-terminal
 *
 * @constructor
 * @params callback
 */
function veneerTerminal( handler ) {

  // Inherit veneerTerminal prototype into handler.
  this.utility.inherits( handler, veneerTerminal );

  var prototype = handler.prototype;
  var commander = prototype.commander;

  // Extend Child Instance with Event Emitter and Settings
  require( 'object-emitter' ).mixin( prototype );
  require( 'object-settings' ).mixin( prototype );

  // Find Best Package for veneerTerminal settings.
  prototype.set( 'base', require( 'path' ).dirname( this.utility.findup( 'package.json', { cwd: require( 'path' ).dirname( process.mainModule.filename ) } ) ) );
  prototype.set( 'package', require( require( 'path' ).join( prototype.get( 'base' ), 'package.json' ) ) );


  // Configure commander.
  commander.usage( prototype.get( 'usage', '[command] [options]' ) );

  // Extend Commander's context with veneerTerminal Properties. This makes veneerTerminal properties available within commander actions.
  Object.defineProperties( commander, {
    log: {
      /**
       *
       * @property log
       */
      value: prototype.log.bind( prototype ),
      enumerable: true,
      configurable: true,
      writable: true
    },
    write: {
      /**
       *
       * @property write
       */
      value: prototype.write.bind( prototype ),
      enumerable: true,
      configurable: true,
      writable: true
    },
    utility: {
      /**
       *
       * @property utility
       */
      value: prototype.utility.bind( prototype ),
      enumerable: true,
      configurable: true,
      writable: true
    }
  });

  // Extend own context.
  prototype = new handler( null, prototype );

  commander._name = prototype.get( 'name' );
  commander.version( prototype.get( 'version' ) );

  if( process.argv.length === 2 ) {
    commander.outputHelp();
  } else {
    commander.parse( process.argv );
  }

  return prototype;

}

/**
 * veneerTerminal Instance Properties
 *
 */
Object.defineProperties( veneerTerminal.prototype, {
  log: {
    /**
     * Commander Instance
     * @for veneerTerminal
     */
    value: function() {

      var args    = Array.prototype.slice.call( arguments );
      var format  = require( 'util' ).format;

      // Format Errors.
      if( args[0] instanceof Error ) {

        if( args[0].code ) {
          args[1] = format( '[code: %s]', args[0].code || 'no_code' ).magenta;
        }

        args[0] = format( 'Error: %s', args[0].message ).red;

      }

      // Prefix with name of Terminal.
      args[0] = [ '  ', ( this.get( 'label' ) || this.get( 'name' ) ).cyan, ': ', args[0] ].join( '' );

      // Output to console.
      console.log.apply( console, args );

      // @chainable.
      return this;

    },
    enumerable: false,
    configurable: true
  },
  write: {
    /**
     * Console Output
     *
     * @for veneerTerminal
     */
    value: function write( string ) {

      try {

        if( string ) {
          console.log( string.cyan );
        }

      } catch( error ) {
        console.log( string );
      }

      // @chainable.
      return this;

    },
    enumerable: false,
    configurable: true
  },
  commander: {
    /**
     * Commander Instance
     * @for veneerTerminal
     */
    value: require( 'commander' ),
    enumerable: false,
    configurable: true
  },
  option: {
    /**
     * veneerTerminal Command
     */
    value: function option( flags, description, fn, defaultValue ) {
      return this.commander.option( flags, description, fn, defaultValue )
    },
    enumerable: true,
    configurable: true
  },
  command: {
    /**
     * veneerTerminal Command
     */
    value: function command( name, desc ) {
      return this.commander.command( name ).description( desc )
    },
    enumerable: true,
    configurable: true
  },
  debug: {
    /**
     * veneerTerminal Debugger
     *
     * @for veneerTerminal
     * @method debug
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: require( 'debug' )( 'veneer:terminal' ),
    enumerable: true,
    configurable: true,
    writable: true
  },
  app_path: {
    /**
     * Get Path to Application
     *
     * @todo Fix.
     *
     * @param _package
     * @param targetName
     * @returns {string}
     */
    value: function app_path ( _package, targetName ) {
      return "/home/" + this._module.package.targets[targetName].ssh.user + "/" + targetName + "/" + _package.name;
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  inline_env: {
    value: function inline_env ( it ) {

      function qescape ( it ) {
        return it.replace( /\\/g, "\\\\" ).replace( /\'/g, "\\'" ).replace( /\`/g, "\\`" );
      }

      function qqescape ( it ) {
        return it.replace( /\\/g, "\\\\" ).replace( /\"/g, '\\"' );
      }

      var k, v, items = [];
      for( k in it ) {
        v = it[k] === null ? "" : it[k].toString();
        items.push( k + "=\"" + qqescape( v ) + "\"" );
      }
      return items.join( " " );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  sshs: {
    value: function sshs ( conf, cmds ) {
      veneerTerminal.debug( 'Executing SSH command(s).' );
      var exec = require( 'child_process' ).exec;

      function qescape ( it ) {
        return it.replace( /\\/g, "\\\\" ).replace( /\'/g, "\\'" ).replace( /\`/g, "\\`" );
      }

      function qqescape ( it ) {
        return it.replace( /\\/g, "\\\\" ).replace( /\"/g, '\\"' );
      }

      function ssh ( conf, cmd ) {
        conf.hosts.forEach( function( host ) {
          var args = [
            "-o", "ForwardAgent=yes", "-o", "StrictHostKeyChecking=no", "-p", conf.port, conf.user + "@" + host, "bash -c '" + qescape( cmd ) + "'"
          ];
          console.log( "ssh", args );
          exec( "ssh", args );
        } );
      }

      ssh( conf, cmds.join( " && " ) );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  init: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function init ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( "Invalid target:", targetName );
        process.exit( 1 );
      }
      var destAppPath = this.app_path( _package, targetName );
      var repoUrl = _package.repository.url;
      if( !repoUrl || _package.repository.type !== 'git' ) {
        console.error( "package.json must have repository of type 'git'" );
        process.exit( 1 );
      }
      sshs( targetConf.ssh, [
        "mkdir -p " + destAppPath, "git clone " + repoUrl + " " + destAppPath, "cd " + destAppPath, "npm install"
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  start: {
    /**
     * Start Module
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function start ( module, callback ) {
      veneerTerminal.debug( 'Start Module.' );

      // Veneer Cluster and Service handlers.
      var Cluster = require( 'veneer-cluster' );
      var Service = require( 'veneer-service' );

      // Start Service
      if( this._package.type === 'service' ) {
        this._instance = Service.start( this._module, this._callback );
      }

      // Start Module
      if( this._package.type === 'cluster' ) {
        this._instance = Cluster.start( this._module, this._callback );
      }

      console.log( require( 'util' ).inspect( this._instance, { showHidden: false, colors: true, depth: 2 } ) )

    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  stop: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function stop ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( "Invalid target:", targetName );
        process.exit( 1 );
      }
      sshs( targetConf.ssh, [
        "cd " + app_path( _package, targetName ), "npm stop"
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  list: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function list ( optParser, _package ) {
      veneerTerminal.debug( 'Listing options.' );

      var name, target;
      for( name in _package.config.targets ) {
        target = _package.config.targets[name];
        console.log( name )
        target.ssh.hosts.forEach( printHost );
      }
      function printHost ( host ) {
        console.log( "  " + host );
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  deploy: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function deploy ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).default( 'branch', null ).default( 'npmforce', null ).argv;

      if( !this._module.package.targets ) {
        console.error( "package.json missing 'config.targets' config" );
        process.exit( 1 );
      }

      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      var forceCommand = "";

      if( argv.npmforce ) {
        forceCommand = " --force"
      }

      if( !targetConf ) {
        console.error( "Invalid target:", targetName );
        process.exit( 1 );
      }
      var env = this.inline_env( targetConf.env );
      if( argv.branch ) {
        proceed( null, argv.branch );
      } else {
        this.default_branch( proceed );
      }

      function proceed ( err, branch ) {
        if( err ) {
          console.error( "Unable to get current branch:", err.stack );
          return;
        }

        sshs( targetConf.ssh, [
          "cd " + app_path( _package, targetName ), "git fetch", "git checkout origin/" + branch, "git submodule update", "npm prune", "npm install" + forceCommand, env + " npm run deploy" ] );
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  abort: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function abort ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( "Invalid target:", targetName );
        process.exit( 1 );
      }
      sshs( targetConf.ssh, [
        "cd " + app_path( _package, targetName ), "npm run deploy-abort"
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  monitor: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function monitor ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]
      if( !targetConf ) {
        console.error( "Invalid target:", targetName );
        process.exit( 1 );
      }
      _package.config.commands = _package.config.commands || {};
      var tailCmd = _package.config.commands.monitor || "tail -f *.log";
      sshs( targetConf.ssh, [
        "cd " + app_path( _package, targetName ), tailCmd
      ] );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  diff: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function diff ( optParser, _package ) {

      // Private Modules
      var Batch = require( 'batch' );
      var argv = this._optParser.demand( 1 ).default( 'branch', null ).argv;
      var targetName = argv._[1]
      var targetConf = _package.config.targets[targetName]

      if( !targetConf ) {
        console.error( "Invalid target:", targetName );
        process.exit( 1 );
      }
      if( argv.branch ) {
        proceed( null, argv.branch );
      } else {
        this.default_branch( proceed );
      }
      function proceed ( err, branch ) {
        if( err ) {
          console.error( "unable to get current branch:", err.stack );
          return;
        }
        this.deploy_diff( _package, targetName, branch, "%C(yellow)%h%Creset %Cgreen%cd%Creset %Cred%an%Creset %s", function( err, gitLog ) {
          if( err ) {
            console.error( "Unable to get diff:", err.stack );
          } else {
            if( !gitLog.trim() ) {
              console.log( "No new code to deploy." );
            } else {
              console.log( gitLog );
            }
          }
        } );
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  get_usage: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function get_usage () {
      var usage = "Usage: $0 [command]\n\nAvailable commands:\n";
      var task;

      for( var taskName in veneerTerminal.tasks ) {
        task = veneerTerminal.tasks[taskName];
        usage += "\n    " + taskName + "\t" + task.info;
      }

      return usage;

    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  exec: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function exec ( cmd, args, opts, cb ) {
      args = args || [];
      opts = opts || {};
      cb = cb || function() {
      };
      opts = this.utility.extend( {
        stdio: [process.stdin, process.stdout, process.stderr]
      }, opts );
      var bin = spawn( cmd, args, opts );
      bin.on( 'exit', cb );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  deploy_diff: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function deploy_diff ( _package, targetName, branch, format, cb ) {
      var exec = require( 'child_process' ).exec;
      var batch = new Batch();
      batch.push( function( cb ) {
        var sshConf = _package.config.targets[targetName].ssh;
        var firstHost = sshConf.hosts[0];
        var destAppPath = app_path( _package, targetName );
        var cmd = "ssh " + "-o ForwardAgent=yes " + "-p " + sshConf.port + " " + sshConf.user + "@" + firstHost + " " + "'cd " + destAppPath + " && git rev-parse HEAD'";
        exec( cmd, function( err, stdout, stderr ) {
          if( err ) {
            err.stderr = stderr;
            err.stdout = stdout;
            err.cmd = cmd;
            cb( err );
          } else {
            cb( null, stdout.trim() );
          }
        } );
      } );
      batch.push( function( cb ) {
        var cmd = "git fetch origin";
        exec( cmd, function( err, stdout, stderr ) {
          if( err ) {
            err.stderr = stderr;
            err.stdout = stdout;
            err.cmd = cmd;
            cb( err );
          } else {
            cb();
          }
        } );
      } );
      batch.end( function( err, results ) {
        if( err ) {
          return cb( err );
        }
        var rev = results[0];
        var cmd = "git log --pretty=format:\"" + format + "\" " + rev + "..origin/" + branch;
        exec( cmd, function( err, stdout, stderr ) {
          if( err ) {
            err.stderr = stderr;
            err.stdout = stdout;
            err.cmd = cmd;
            cb( err );
          } else {
            cb( null, stdout.trim() );
          }
        } );
      } );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  default_branch: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function default_branch ( cb ) {
      var exec = require( 'child_process' ).exec;
      var cmd = "git rev-parse --abbrev-ref HEAD";
      exec( cmd, function( err, stdout, stderr ) {
        if( err ) {
          err.stderr = stderr;
          err.stdout = stdout;
          err.cmd = cmd;
          cb( err );
        } else {
          cb( null, stdout.trim() );
        }
      } );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  run_env: {
    /**
     * Start veneerTerminal
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function run_env ( optParser, _package ) {
      var argv = this._optParser.demand( 1 ).argv;
      var targetName = argv._[1];
      var target = _package.config.targets[targetName];
      if( !target ) {
        console.error( "Invalid target:", targetName );
        process.exit( 1 );
      }
      var args = argv._.slice( 2 )
      var env = this.utility.extend( this.utility.extend( {}, target.env ), process.env )
      var child = spawn( 'bash', ['-c', args.join( " " )], {
        stdio: 'inherit',
        env: env,
      } )
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  utility: {
    /**
     * veneerTerminal Utilities
     *
     * @for veneerTerminal
     */
    value: require( './common/utility' ),
    enumerable: true,
    configurable: true,
    writable: true
  }
});

/**
 * Export veneerTerminal Class
 *
 */
Object.defineProperties( module.exports = veneerTerminal, {
  create: {
    /**
     * Create veneerTerminal Instance
     *
     * @param callback
     * @returns {veneerTerminal}
     */
    value: function create ( handler ) {
      return new veneerTerminal( handler );
    },
    enumerable: true,
    configurable: true,
    writable: true
  },
  tasks: {
    value: {
      list: {
        fn: veneerTerminal.prototype.list,
        info: "list available deploy targets"
      },
      init: {
        fn: veneerTerminal.prototype.init,
        info: "<target> - prepares target to accept deployments"
      },
      start: {
        fn: veneerTerminal.prototype.start,
        info: "<target> - starts the remote server"
      },
      stop: {
        fn: veneerTerminal.prototype.stop,
        info: "<target> - stops the remote server"
      },
      deploy: {
        fn: veneerTerminal.prototype.deploy,
        info: "<target> [--branch branch] [--npmforce] - deploy code"
      }
    },
    enumerable: true,
    configurable: true,
    writable: true
  }
});
